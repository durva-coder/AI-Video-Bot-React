/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 public/models/667909a260bbb5682042293a.glb -o src/components/Avatar.jsx -r public 
*/

// import { useGLTF } from "@react-three/drei";
// import { useFrame, useLoader } from "@react-three/fiber";
// import React, { useMemo, useEffect, useState, useRef } from "react";
// import useSpeechRecognition from "../hooks/useSpeechToText/index";
// import * as THREE from "three";

// // import axios from "axios";
// // import { Buffer } from "buffer";

// const corresponding = {
//   A: "viseme_PP",
//   B: "viseme_kk",
//   C: "viseme_I",
//   D: "viseme_AA",
//   E: "viseme_O",
//   F: "viseme_U",
//   G: "viseme_FF",
//   H: "viseme_TH",
//   X: "viseme_PP",
// };

// export function Avatar(props) {
//   const { isListening, isSpeaking, responseData, setResponseData } =
//     useSpeechRecognition(); // Correct the import path to useSpeechRecognition

//   const [text, setText] = useState("");
//   const [cues, setCues] = useState([]);
//   const speechSynthesisRef = useRef(null);

//   useEffect(() => {
//     if ("speechSynthesis" in window) {
//       speechSynthesisRef.current = window.speechSynthesis;
//     }
//   }, []);

//   const handleTextChange = (event) => {
//     setText(event.target.value);
//   };

//   const generateCues = () => {
//     const utterance = new SpeechSynthesisUtterance(responseData);
//     const cues = [];

//     utterance.onboundary = (event) => {
//       if (event.name === "word") {
//         const startTime = event.elapsedTime.toFixed(2);
//         const endTime = (event.elapsedTime + event.duration).toFixed(2);
//         const word = event.character.trim();

//         cues.push({
//           word,
//           startTime,
//           endTime,
//         });
//       }
//     };

//     speechSynthesisRef.current.speak(utterance);

//     utterance.onend = () => {
//       setCues(cues);
//     };
//   };

//   // const [text, setText] = useState("");
//   const [mouthCues, setMouthCues] = useState([]);

//   // const handleChange = (e) => {
//   //   setText(e.target.value);
//   // };

//   // const [audioBuffer, setAudioBuffer] = useState(null);
//   // const [alignment, setAlignment] = useState(null);
//   // const [error, setError] = useState(null);

//   // useEffect(() => {
//   //   const data = {
//   //     text: "Born and raised in the charming south, I can add a touch of sweet southern hospitality to your audiobooks and podcasts",
//   //     model_id: "eleven_multilingual_v2",
//   //     voice_settings: {
//   //       stability: 0.5,
//   //       similarity_boost: 0.75,
//   //     },
//   //   };

//   //   axios
//   //     .post("http://localhost:7777/api", data)
//   //     .then((response) => {
//   //       if (response.status !== 200) {
//   //         setError(
//   //           `Error encountered, status: ${response.status}, content: ${response.data}`
//   //         );
//   //         return;
//   //       }

//   //       const audioBase64 = response.data.audio_base64;
//   //       const audioBuffer = Buffer.from(audioBase64, "base64");
//   //       setAudioBuffer(audioBuffer);
//   //       setAlignment(response.data.alignment);
//   //     })
//   //     .catch((error) => {
//   //       setError(error.message);
//   //     });
//   // }, []);

//   //   const VOICE_ID = "21m00Tcm4TlvDq8ikWAM"; // Rachel
//   //   const XI_API_KEY = "sk_3576d5ff2313129c03dcbe17e309d9969a9d6bc5b39e2a56";

//   //   const url = `https://api.elevenlabs.io/v1/text-to-speech/${VOICE_ID}/with-timestamps`;

//   //   const headers = {
//   //     "Content-Type": "application/json",
//   //     // "xi-api-key": XI_API_KEY,
//   //     Authorization: `Bearer ${XI_API_KEY}`,
//   //     "Access-Control-Allow-Origin": "*",
//   //   };

//   //   const data = {
//   //     text: "Born and raised in the charming south",
//   //     model_id: "eleven_multilingual_v2",
//   //     voice_settings: {
//   //       stability: 0.5,
//   //       similarity_boost: 0.75,
//   //     },
//   //   };

//   //   useEffect(() => {
//   //     axios
//   //       .post(url, data, { headers })
//   //       .then((response) => {
//   //         if (response.status !== 200) {
//   //           setError(
//   //             `Error encountered, status: ${response.status}, content: ${response.data}`
//   //           );
//   //           return;
//   //         }

//   //         const audioBase64 = response.data.audio_base64;
//   //         const audioBuffer = Buffer.from(audioBase64, "base64");
//   //         setAudioBuffer(audioBuffer);
//   //         setAlignment(response.data.alignment);
//   //       })
//   //       .catch((error) => {
//   //         setError(error.message);
//   //       });
//   //   }, []);

//   let script;

//   const arr = [
//     "hello",
//     "hey",
//     "hey there",
//     "hello there",
//     "hi there",
//     "hi",
//     "howdy",
//     "hi how are you",
//     "hello how are you",
//   ];

//   if (!isListening) {
//     // playAudio = true;
//     if (arr.includes(text.toLowerCase().trim())) {
//       script = "greet";
//     } else {
//       script = "idontknow";
//     }
//   }

//   const audio = useMemo(() => new Audio(`/audios/${script}.mp3`), [script]);

//   useEffect(() => {
//     if (isSpeaking) {
//       audio.play();
//       // setReply(responseData);
//     } else {
//       audio.pause();
//       // setReply("");
//       setResponseData("");
//     }
//   }, [isSpeaking, script, responseData]);

//   const { nodes, materials } = useGLTF("/models/667909a260bbb5682042293a.glb");

//   const jsonFile = useLoader(THREE.FileLoader, `audios/${script}.json`);
//   const lipsync = JSON.parse(jsonFile);

//   generateCues();

//   console.log(cues);

//   useFrame(() => {
//     const currentAudioTime = audio.currentTime;

//     Object.values(corresponding).forEach((value) => {
//       nodes.Wolf3D_Head.morphTargetInfluences[
//         nodes.Wolf3D_Head.morphTargetDictionary[value]
//       ] = 0;

//       nodes.Wolf3D_Teeth.morphTargetInfluences[
//         nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//       ] = 0;
//     });

//     for (let i = 0; i < lipsync.mouthCues.length; i++) {
//       const mouthCue = lipsync.mouthCues[i];

//       if (
//         currentAudioTime >= mouthCue.start &&
//         currentAudioTime <= mouthCue.end
//       ) {
//         nodes.Wolf3D_Head.morphTargetInfluences[
//           nodes.Wolf3D_Head.morphTargetDictionary[corresponding[mouthCue.value]]
//         ] = 1;

//         nodes.Wolf3D_Teeth.morphTargetInfluences[
//           nodes.Wolf3D_Teeth.morphTargetDictionary[
//             corresponding[mouthCue.value]
//           ]
//         ] = 1;
//         break;
//       }
//     }
//     setResponseData("");
//   });

//   return (
//     <group {...props} dispose={null}>
//       <primitive object={nodes.Hips} />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Hair.geometry}
//         material={materials.Wolf3D_Hair}
//         skeleton={nodes.Wolf3D_Hair.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//         material={materials.Wolf3D_Outfit_Top}
//         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//         material={materials.Wolf3D_Outfit_Bottom}
//         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//         material={materials.Wolf3D_Outfit_Footwear}
//         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Body.geometry}
//         material={materials.Wolf3D_Body}
//         skeleton={nodes.Wolf3D_Body.skeleton}
//       />
//       <skinnedMesh
//         name="EyeLeft"
//         geometry={nodes.EyeLeft.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeLeft.skeleton}
//         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="EyeRight"
//         geometry={nodes.EyeRight.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeRight.skeleton}
//         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Head"
//         geometry={nodes.Wolf3D_Head.geometry}
//         material={materials.Wolf3D_Skin}
//         skeleton={nodes.Wolf3D_Head.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Teeth"
//         geometry={nodes.Wolf3D_Teeth.geometry}
//         material={materials.Wolf3D_Teeth}
//         skeleton={nodes.Wolf3D_Teeth.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//       />
//     </group>
//   );
// }

// useGLTF.preload("/models/667909a260bbb5682042293a.glb");

// import React, { useState, useEffect, useRef } from "react";
// import { useGLTF } from "@react-three/drei";
// import { useFrame, useLoader } from "@react-three/fiber";
// import useSpeechRecognition from "../hooks/useSpeechToText/index";
// import * as THREE from "three";

// const corresponding = {
//   A: "viseme_PP",
//   B: "viseme_kk",
//   C: "viseme_I",
//   D: "viseme_AA",
//   E: "viseme_O",
//   F: "viseme_U",
//   G: "viseme_FF",
//   H: "viseme_TH",
//   X: "viseme_PP",
// };

// export function Avatar(props) {
//   const { isListening, isSpeaking, responseData, setResponseData } =
//     useSpeechRecognition(); // Adjust the import path to useSpeechRecognition

//   const [cues, setCues] = useState([]);
//   const speechSynthesisRef = useRef(null);
//   const utteranceRef = useRef(null);
//   const startTimeRef = useRef(0);
//   const elapsedTimeRef = useRef(0);

//   // Initialize speech synthesis when component mounts
//   useEffect(() => {
//     if ("speechSynthesis" in window) {
//       speechSynthesisRef.current = window.speechSynthesis;
//     }
//   }, []);

//   useEffect(() => {
//     if (responseData) {
//       const utterance = new SpeechSynthesisUtterance(responseData);
//       utteranceRef.current = utterance;
//       const cues = [];

//       utterance.onboundary = (event) => {
//         if (event.name === "word") {
//           const start = event.elapsedTime * 1000; // Convert to milliseconds
//           const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
//           const value = responseData
//             .substring(event.charIndex, event.charIndex + event.charLength)
//             .trim();
//           const viseme = corresponding[value.charAt(0).toUpperCase()] || "X";

//           cues.push({
//             value: viseme,
//             start,
//             end,
//           });
//         }
//       };

//       speechSynthesisRef.current.speak(utterance);

//       utterance.onend = () => {
//         setCues(cues);
//         console.log("Cues:", cues);
//       };
//     }
//   }, [responseData]);

//   // Load 3D model and corresponding lip sync data
//   const { nodes, materials } = useGLTF("/models/667909a260bbb5682042293a.glb");

//   useFrame(() => {
//     const currentAudioTime = speechSynthesisRef.current
//       ? speechSynthesisRef.current.currentTime * 1000
//       : 0;

//     console.log(currentAudioTime);
//     Object.values(corresponding).forEach((value) => {
//       nodes.Wolf3D_Head.morphTargetInfluences[
//         nodes.Wolf3D_Head.morphTargetDictionary[value]
//       ] = 0;

//       nodes.Wolf3D_Teeth.morphTargetInfluences[
//         nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//       ] = 0;
//     });

//     for (let i = 0; i < cues.length; i++) {
//       const mouthCue = cues[i];
//       console.log(currentAudioTime);
//       if (
//         currentAudioTime >= mouthCue.start &&
//         currentAudioTime <= mouthCue.end
//       ) {
//         const viseme = mouthCue.value;

//         nodes.Wolf3D_Head.morphTargetInfluences[
//           nodes.Wolf3D_Head.morphTargetDictionary[viseme]
//         ] = 1;

//         nodes.Wolf3D_Teeth.morphTargetInfluences[
//           nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
//         ] = 1;
//         break;
//       }
//     }
//   });

//   return (
//     <group {...props} dispose={null}>
//       <primitive object={nodes.Hips} />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Hair.geometry}
//         material={materials.Wolf3D_Hair}
//         skeleton={nodes.Wolf3D_Hair.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//         material={materials.Wolf3D_Outfit_Top}
//         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//         material={materials.Wolf3D_Outfit_Bottom}
//         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//         material={materials.Wolf3D_Outfit_Footwear}
//         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Body.geometry}
//         material={materials.Wolf3D_Body}
//         skeleton={nodes.Wolf3D_Body.skeleton}
//       />
//       <skinnedMesh
//         name="EyeLeft"
//         geometry={nodes.EyeLeft.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeLeft.skeleton}
//         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="EyeRight"
//         geometry={nodes.EyeRight.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeRight.skeleton}
//         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Head"
//         geometry={nodes.Wolf3D_Head.geometry}
//         material={materials.Wolf3D_Skin}
//         skeleton={nodes.Wolf3D_Head.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Teeth"
//         geometry={nodes.Wolf3D_Teeth.geometry}
//         material={materials.Wolf3D_Teeth}
//         skeleton={nodes.Wolf3D_Teeth.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//       />
//     </group>
//   );
// }

// // Preload 3D model
// useGLTF.preload("/models/667909a260bbb5682042293a.glb");

// import React, { useState, useEffect, useRef } from "react";
// import { useGLTF } from "@react-three/drei";
// import { useFrame } from "@react-three/fiber";
// import useSpeechRecognition from "../hooks/useSpeechToText/index";

// const corresponding = {
//   A: "viseme_PP",
//   B: "viseme_kk",
//   C: "viseme_I",
//   D: "viseme_AA",
//   E: "viseme_O",
//   F: "viseme_U",
//   G: "viseme_FF",
//   H: "viseme_TH",
//   X: "viseme_PP",
// };

// export function Avatar(props) {
//   const { responseData } = useSpeechRecognition();
//   const [cues, setCues] = useState([]);
//   const utteranceRef = useRef(null);
//   const startTimeRef = useRef(0);
//   const speechSynthesisRef = useRef(null);

//   useEffect(() => {
//     if ("speechSynthesis" in window) {
//       speechSynthesisRef.current = window.speechSynthesis;
//     }
//   }, []);

//   useEffect(() => {
//     if (responseData) {
//       const utterance = new SpeechSynthesisUtterance(responseData);
//       utteranceRef.current = utterance;
//       const generatedCues = [];

//       utterance.onboundary = (event) => {
//         if (event.name === "word") {
//           const start = event.elapsedTime * 1000; // Convert to milliseconds
//           const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
//           const value = responseData
//             .substring(event.charIndex, event.charIndex + event.charLength)
//             .trim();
//           const viseme = corresponding[value.charAt(0).toUpperCase()] || "X";

//           generatedCues.push({
//             value: viseme,
//             start,
//             end,
//           });
//         }
//       };

//       speechSynthesisRef.current.speak(utterance);

//       utterance.onend = () => {
//         setCues(generatedCues);
//         console.log("Cues:", generatedCues);
//       };
//     }
//   }, [responseData]);

//   const { nodes, materials } = useGLTF("/models/667909a260bbb5682042293a.glb");

//   useFrame(() => {
//     console.log("(speechSynthesisRef.current", speechSynthesisRef.current);
//     if (speechSynthesisRef.current && speechSynthesisRef.current.speaking) {
//       const currentTime = speechSynthesisRef.current.currentTime * 1000;

//       Object.values(corresponding).forEach((value) => {
//         nodes.Wolf3D_Head.morphTargetInfluences[
//           nodes.Wolf3D_Head.morphTargetDictionary[value]
//         ] = 0;

//         nodes.Wolf3D_Teeth.morphTargetInfluences[
//           nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//         ] = 0;
//       });

//       for (let i = 0; i < cues.length; i++) {
//         const mouthCue = cues[i];
//         const startTime = mouthCue.start;
//         const endTime = mouthCue.end;

//         console.log("currentTime", currentTime);
//         console.log("startTime", startTime);
//         console.log("currentTime >= startTime", currentTime >= startTime);
//         console.log("currentTime <= endTime", currentTime <= endTime);
//         console.log(
//           "currentTime >= startTime && currentTime <= endTime",
//           currentTime >= startTime && currentTime <= endTime
//         );

//         if (currentTime >= startTime && currentTime <= endTime) {
//           console.log(currentTime);
//           const viseme = mouthCue.value;

//           nodes.Wolf3D_Head.morphTargetInfluences[
//             nodes.Wolf3D_Head.morphTargetDictionary[viseme]
//           ] = 1;

//           nodes.Wolf3D_Teeth.morphTargetInfluences[
//             nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
//           ] = 1;
//           break;
//         }
//       }
//     }
//   });

//   return (
//     <group {...props} dispose={null}>
//       <primitive object={nodes.Hips} />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Hair.geometry}
//         material={materials.Wolf3D_Hair}
//         skeleton={nodes.Wolf3D_Hair.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//         material={materials.Wolf3D_Outfit_Top}
//         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//         material={materials.Wolf3D_Outfit_Bottom}
//         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//         material={materials.Wolf3D_Outfit_Footwear}
//         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Body.geometry}
//         material={materials.Wolf3D_Body}
//         skeleton={nodes.Wolf3D_Body.skeleton}
//       />
//       <skinnedMesh
//         name="EyeLeft"
//         geometry={nodes.EyeLeft.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeLeft.skeleton}
//         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="EyeRight"
//         geometry={nodes.EyeRight.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeRight.skeleton}
//         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Head"
//         geometry={nodes.Wolf3D_Head.geometry}
//         material={materials.Wolf3D_Skin}
//         skeleton={nodes.Wolf3D_Head.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Teeth"
//         geometry={nodes.Wolf3D_Teeth.geometry}
//         material={materials.Wolf3D_Teeth}
//         skeleton={nodes.Wolf3D_Teeth.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//       />
//     </group>
//   );
// }

// // Preload 3D model
// useGLTF.preload("/models/667909a260bbb5682042293a.glb");

// export default Avatar;

import React, { useState, useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import useSpeechRecognition from "../hooks/useSpeechToText/index";

const corresponding = {
  // A: "viseme_PP",
  // B: "viseme_kk",
  // C: "viseme_I",
  // D: "viseme_AA",
  // E: "viseme_O",
  // F: "viseme_U",
  // G: "viseme_FF",
  // H: "viseme_TH",
  // X: "viseme_PP",

  // P: "viseme_PP",
  // B: "viseme_PP",
  // M: "viseme_PP",
  // F: "viseme_FF",
  // V: "viseme_FF",
  // TH: "viseme_TH",
  // D: "viseme_DD",
  // T: "viseme_DD",
  // N: "viseme_DD",
  // K: "viseme_kk",
  // G: "viseme_kk",
  // NG: "viseme_kk",
  // CH: "viseme_CH",
  // J: "viseme_CH",
  // SH: "viseme_CH",
  // S: "viseme_SS",
  // Z: "viseme_SS",
  // L: "viseme_nn",
  // R: "viseme_RR",
  // AA: "viseme_aa",
  // E: "viseme_E",
  // I: "viseme_I",
  // O: "viseme_O",
  // U: "viseme_U",
  // SIL: "viseme_sil",

  X: "viseme_PP",
  P: "viseme_PP",
  B: "viseme_PP",
  M: "viseme_PP",
  F: "viseme_FF",
  V: "viseme_FF",
  TH: "viseme_TH",
  D: "viseme_DD",
  T: "viseme_DD",
  N: "viseme_DD",
  K: "viseme_kk",
  G: "viseme_kk",
  NG: "viseme_kk",
  CH: "viseme_CH",
  J: "viseme_CH",
  SH: "viseme_CH",
  S: "viseme_SS",
  Z: "viseme_SS",
  L: "viseme_nn",
  R: "viseme_RR",
  AA: "viseme_aa",
  E: "viseme_E",
  I: "viseme_I",
  O: "viseme_O",
  U: "viseme_U",
  SIL: "viseme_sil",
  TH_: "viseme_TH_", // for "th" in "this" or "that"
  CH_: "viseme_CH_", // for "ch" in "church" or "change"
  A_CAT: "viseme_A_CAT", // for "a" in "cat"
  A_FACE: "viseme_A_FACE", // for "a" in "face"
};

export function Avatar1(props) {
  const { responseData } = useSpeechRecognition();
  const [cues, setCues] = useState([]);
  const utteranceRef = useRef(null);
  const startTimeRef = useRef(0);
  const speechSynthesisRef = useRef(null);

  useEffect(() => {
    if ("speechSynthesis" in window) {
      speechSynthesisRef.current = window.speechSynthesis;
    }
  }, []);

  // useEffect(() => {
  //   if (responseData) {
  //     const utterance = new SpeechSynthesisUtterance(responseData);

  //     utteranceRef.current = utterance;
  //     const generatedCues = [];

  //     utterance.onboundary = (event) => {
  //       if (event.name === "word") {
  //         // console.log(event);
  //         const start = event.elapsedTime * 1000; // Convert to milliseconds
  //         const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
  //         const value = responseData
  //           .substring(event.charIndex, event.charIndex + event.charLength)
  //           .trim();
  //         console.log(value);
  //         const viseme = corresponding[value.charAt(0).toUpperCase()] || "X";

  //         generatedCues.push({
  //           value: viseme,
  //           start,
  //           end,
  //         });

  //         // Update the current time of the speech synthesis
  //         startTimeRef.current = event.elapsedTime * 1000;
  //       }
  //     };
  //     // const voices = speechSynthesis.getVoices();
  //     // const googleUsEnglishVoice = voices.find(
  //     //   (voice) => voice.name === "Google US English"
  //     // );

  //     // utterance.voice = googleUsEnglishVoice;
  //     speechSynthesisRef.current.speak(utterance);

  //     utterance.onstart = () => {
  //       setCues(generatedCues);
  //       console.log("Cues:", generatedCues);
  //     };
  //   }
  // }, [responseData]);

  useEffect(() => {
    if (responseData) {
      const utterance = new SpeechSynthesisUtterance(responseData);
      utteranceRef.current = utterance;
      const generatedCues = [];

      utterance.onboundary = (event) => {
        if (event.name === "word") {
          const charIndex = event.charIndex;
          const charLength = event.charLength;
          const text = utterance.text;
          const chars = [];

          for (let i = charIndex; i < charIndex + charLength; i++) {
            const char = text.charAt(i);
            chars.push(char);
          }

          chars.forEach((char) => {
            const start = event.elapsedTime * 1000; // Convert to milliseconds
            const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
            const viseme = corresponding[char.toUpperCase()] || "X";

            generatedCues.push({
              value: viseme,
              start,
              end,
            });
          });

          // Update the current time of the speech synthesis
          startTimeRef.current = event.elapsedTime * 1000;
        }
      };

      speechSynthesisRef.current.speak(utterance);

      utterance.onstart = () => {
        setCues(generatedCues);
        console.log("Cues:", generatedCues);
      };
    }
  }, [responseData]);

  const { nodes, materials } = useGLTF("/models/667909a260bbb5682042293a.glb");

  useFrame(() => {
    if (speechSynthesisRef.current && speechSynthesisRef.current.speaking) {
      const currentTime = startTimeRef.current;
      console.log(currentTime);

      Object.values(corresponding).forEach((value) => {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = 0;

        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = 0;
      });

      for (let i = 0; i < cues.length; i++) {
        const mouthCue = cues[i];
        const startTime = mouthCue.start;
        const endTime = mouthCue.end;

        if (currentTime >= startTime && currentTime <= endTime) {
          const viseme = mouthCue.value;

          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 1;

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 1;
          break;
        }
      }
      nodes.Wolf3D_Head.morphTargetInfluences[
        nodes.Wolf3D_Head.morphTargetDictionary[viseme]
      ] = 0;

      nodes.Wolf3D_Teeth.morphTargetInfluences[
        nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
      ] = 0;
    }
  });

  return (
    <group {...props} dispose={null}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
}

// Preload 3D model
useGLTF.preload("/models/667909a260bbb5682042293a.glb");
