/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 public/models/667909a260bbb5682042293a.glb -o src/components/Avatar.jsx -r public 
*/

import React, { useState, useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import useSpeechRecognition1 from "../hooks/useSpeechToText/index";

const corresponding = {
  X: "viseme_PP",
  P: "viseme_PP",
  B: "viseme_PP",
  M: "viseme_PP",
  F: "viseme_FF",
  V: "viseme_FF",
  TH: "viseme_TH",
  D: "viseme_DD",
  T: "viseme_DD",
  N: "viseme_DD",
  K: "viseme_kk",
  G: "viseme_kk",
  NG: "viseme_kk",
  CH: "viseme_CH",
  J: "viseme_CH",
  SH: "viseme_CH",
  S: "viseme_SS",
  Z: "viseme_SS",
  L: "viseme_nn",
  R: "viseme_RR",
  AA: "viseme_aa",
  E: "viseme_E",
  I: "viseme_I",
  O: "viseme_O",
  U: "viseme_U",
  SIL: "viseme_sil",
  TH_: "viseme_TH_", // for "th" in "this" or "that"
  CH_: "viseme_CH_", // for "ch" in "church" or "change"
  A_CAT: "viseme_A_CAT", // for "a" in "cat"
  A_FACE: "viseme_A_FACE", // for "a" in "face"
};

export function Avatar1(props) {
  const { responseData } = useSpeechRecognition1();
  const [cues, setCues] = useState([]);
  const utteranceRef = useRef(null);
  const startTimeRef = useRef(0);
  const speechSynthesisRef = useRef(null);

  useEffect(() => {
    if ("speechSynthesis" in window) {
      speechSynthesisRef.current = window.speechSynthesis;
    }
  }, []);

  useEffect(() => {
    if (responseData) {
      const utterance = new SpeechSynthesisUtterance(responseData);
      utteranceRef.current = utterance;
      const generatedCues = [];

      utterance.onboundary = (event) => {
        if (event.name === "word") {
          const charIndex = event.charIndex;
          const charLength = event.charLength;
          const text = utterance.text;
          const chars = [];

          for (let i = charIndex; i < charIndex + charLength; i++) {
            const char = text.charAt(i);
            chars.push(char);
          }

          chars.forEach((char) => {
            const start = event.elapsedTime * 1000; // Convert to milliseconds
            const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
            const viseme = corresponding[char.toUpperCase()] || "X";

            generatedCues.push({
              value: viseme,
              start,
              end,
            });
          });

          // Update the current time of the speech synthesis
          startTimeRef.current = event.elapsedTime * 1000;
        }
      };

      speechSynthesisRef.current.speak(utterance);

      utterance.onstart = () => {
        setCues(generatedCues);
      };
    }
  }, [responseData]);

  const { nodes, materials } = useGLTF("/models/667909a260bbb5682042293a.glb");

  useFrame(() => {
    if (speechSynthesisRef.current && speechSynthesisRef.current.speaking) {
      const currentTime = startTimeRef.current;

      Object.values(corresponding).forEach((value) => {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = 0;

        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = 0;
      });

      for (let i = 0; i < cues.length; i++) {
        const mouthCue = cues[i];
        const startTime = mouthCue.start;
        const endTime = mouthCue.end;

        if (currentTime >= startTime && currentTime <= endTime) {
          const viseme = mouthCue.value;

          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 1;

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 1;
          break;
        }
      }
      nodes.Wolf3D_Head.morphTargetInfluences[
        nodes.Wolf3D_Head.morphTargetDictionary[viseme]
      ] = 0;

      nodes.Wolf3D_Teeth.morphTargetInfluences[
        nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
      ] = 0;
    }
  });

  return (
    <group {...props} dispose={null}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
}

// Preload 3D model
useGLTF.preload("/models/667909a260bbb5682042293a.glb");
