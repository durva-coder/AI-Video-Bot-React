/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 public/models/667d2dc7ab338d43c837c83c.glb -o src/components/Avatar.jsx -r public 
*/

import React, { useState, useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import useSpeechRecognition from "../hooks/useSpeechToText/index";
import * as THREE from "three";

const corresponding = {
  // A: "viseme_PP",
  // B: "viseme_kk",
  // C: "viseme_I",
  // D: "viseme_AA",
  // E: "viseme_O",
  // F: "viseme_U",
  // G: "viseme_FF",
  // H: "viseme_TH",
  // X: "viseme_PP",

  // P: "viseme_PP",
  // B: "viseme_PP",
  // M: "viseme_PP",
  // F: "viseme_FF",
  // V: "viseme_FF",
  // TH: "viseme_TH",
  // D: "viseme_DD",
  // T: "viseme_DD",
  // N: "viseme_DD",
  // K: "viseme_kk",
  // G: "viseme_kk",
  // NG: "viseme_kk",
  // CH: "viseme_CH",
  // J: "viseme_CH",
  // SH: "viseme_CH",
  // S: "viseme_SS",
  // Z: "viseme_SS",
  // L: "viseme_nn",
  // R: "viseme_RR",
  // AA: "viseme_aa",
  // E: "viseme_E",
  // I: "viseme_I",
  // O: "viseme_O",
  // U: "viseme_U",
  // SIL: "viseme_sil",

  X: "viseme_PP",
  P: "viseme_PP",
  B: "viseme_PP",
  M: "viseme_PP",
  F: "viseme_FF",
  V: "viseme_FF",
  TH: "viseme_TH",
  D: "viseme_DD",
  T: "viseme_DD",
  N: "viseme_DD",
  K: "viseme_kk",
  G: "viseme_kk",
  NG: "viseme_kk",
  CH: "viseme_CH",
  J: "viseme_CH",
  SH: "viseme_CH",
  S: "viseme_SS",
  Z: "viseme_SS",
  L: "viseme_nn",
  R: "viseme_RR",
  AA: "viseme_aa",
  E: "viseme_E",
  I: "viseme_I",
  O: "viseme_O",
  U: "viseme_U",
  SIL: "viseme_sil",
  TH_: "viseme_TH_", // for "th" in "this" or "that"
  CH_: "viseme_CH_", // for "ch" in "church" or "change"
  A_CAT: "viseme_A_CAT", // for "a" in "cat"
  A_FACE: "viseme_A_FACE", // for "a" in "face"
};

export function Avatar(props) {
  const { responseData } = useSpeechRecognition();
  const [cues, setCues] = useState([]);
  const utteranceRef = useRef(null);
  const startTimeRef = useRef(0);
  const speechSynthesisRef = useRef(null);

  const smoothMorphTarget = true;
  const morphTargetSmoothing = 0.5;

  useEffect(() => {
    if ("speechSynthesis" in window) {
      speechSynthesisRef.current = window.speechSynthesis;
    }
  }, []);

  useEffect(() => {
    if (responseData) {
      const utterance = new SpeechSynthesisUtterance(responseData);
      utteranceRef.current = utterance;
      const generatedCues = [];

      utterance.onboundary = (event) => {
        if (event.name === "word") {
          const charIndex = event.charIndex;
          const charLength = event.charLength;
          const text = utterance.text;
          const chars = [];

          for (let i = charIndex; i < charIndex + charLength; i++) {
            const char = text.charAt(i);
            chars.push(char);
          }

          chars.forEach((char) => {
            const start = event.elapsedTime * 1000; // Convert to milliseconds
            const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
            const viseme = corresponding[char.toUpperCase()] || "X";

            generatedCues.push({
              value: viseme,
              start,
              end,
            });
          });

          // Update the current time of the speech synthesis
          startTimeRef.current = event.elapsedTime * 1000;
        }
      };

      speechSynthesisRef.current.speak(utterance);

      utterance.onstart = () => {
        setCues(generatedCues);
        console.log("Cues:", generatedCues);
      };
    }
  }, [responseData]);

  const { nodes, materials } = useGLTF("/models/667d2dc7ab338d43c837c83c.glb");

  useFrame(() => {
    if (speechSynthesisRef.current && speechSynthesisRef.current.speaking) {
      const currentTime = startTimeRef.current;
      console.log(currentTime);

      // Object.values(corresponding).forEach((value) => {
      //   nodes.Wolf3D_Head.morphTargetInfluences[
      //     nodes.Wolf3D_Head.morphTargetDictionary[value]
      //   ] = 0;

      //   nodes.Wolf3D_Teeth.morphTargetInfluences[
      //     nodes.Wolf3D_Teeth.morphTargetDictionary[value]
      //   ] = 0;
      // });

      Object.values(corresponding).forEach((value) => {
        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ] = 0;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ] = 0;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[value]
            ],
            0,
            morphTargetSmoothing
          );

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[value]
            ],
            0,
            morphTargetSmoothing
          );
        }
      });

      for (let i = 0; i < cues.length; i++) {
        const mouthCue = cues[i];
        const startTime = mouthCue.start;
        const endTime = mouthCue.end;

        if (currentTime >= startTime && currentTime <= endTime) {
          const viseme = mouthCue.value;

          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 1;

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 1;
          break;
        }
      }

      // for (let i = 0; i < cues.length; i++) {
      //   const mouthCue = cues[i];
      //   const startTime = mouthCue.start;
      //   const endTime = mouthCue.end;
      //   if (currentTime >= startTime && currentTime <= endTime) {
      //     if (!smoothMorphTarget) {
      //       nodes.Wolf3D_Head.morphTargetInfluences[
      //         nodes.Wolf3D_Head.morphTargetDictionary[
      //           corresponding[mouthCue.value]
      //         ]
      //       ] = 1;
      //       nodes.Wolf3D_Teeth.morphTargetInfluences[
      //         nodes.Wolf3D_Teeth.morphTargetDictionary[
      //           corresponding[mouthCue.value]
      //         ]
      //       ] = 1;
      //     } else {
      //       nodes.Wolf3D_Head.morphTargetInfluences[
      //         nodes.Wolf3D_Head.morphTargetDictionary[
      //           corresponding[mouthCue.value]
      //         ]
      //       ] = THREE.MathUtils.lerp(
      //         nodes.Wolf3D_Head.morphTargetInfluences[
      //           nodes.Wolf3D_Head.morphTargetDictionary[
      //             corresponding[mouthCue.value]
      //           ]
      //         ],
      //         1,
      //         morphTargetSmoothing
      //       );
      //       nodes.Wolf3D_Teeth.morphTargetInfluences[
      //         nodes.Wolf3D_Teeth.morphTargetDictionary[
      //           corresponding[mouthCue.value]
      //         ]
      //       ] = THREE.MathUtils.lerp(
      //         nodes.Wolf3D_Teeth.morphTargetInfluences[
      //           nodes.Wolf3D_Teeth.morphTargetDictionary[
      //             corresponding[mouthCue.value]
      //           ]
      //         ],
      //         1,
      //         morphTargetSmoothing
      //       );
      //     }

      //     break;
      //   }
      // }
    } else {
      Object.values(corresponding).forEach((value) => {
        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ] = 0;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ] = 0;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[value]
            ],
            0,
            morphTargetSmoothing
          );

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[value]
            ],
            0,
            morphTargetSmoothing
          );
        }
      });
    }
  });

  return (
    <group {...props} dispose={null}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Glasses.geometry}
        material={materials.Wolf3D_Glasses}
        skeleton={nodes.Wolf3D_Glasses.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Headwear.geometry}
        material={materials.Wolf3D_Headwear}
        skeleton={nodes.Wolf3D_Headwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
}

useGLTF.preload("/models/667d2dc7ab338d43c837c83c.glb");
