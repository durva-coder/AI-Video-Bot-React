/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 public/models/667d2dc7ab338d43c837c83c.glb -o src/components/Avatar.jsx -r public 
*/

// import React, { useState, useEffect, useRef } from "react";
// import { useGLTF } from "@react-three/drei";
// import { useFrame } from "@react-three/fiber";
// import useSpeechRecognition1 from "../hooks/useSpeechToText/index";
// import * as THREE from "three";
// import { Polly } from "aws-sdk";
// import { Buffer } from "buffer";

// const polly = new Polly({
//   credentials: {
//     accessKeyId: "AKIASLWIJDRLMW46KAFQ",
//     secretAccessKey: "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",
//   },
//   region: "ap-south-1",
// });

// const corresponding = {
//   // A: "viseme_PP",
//   // B: "viseme_kk",
//   // C: "viseme_I",
//   // D: "viseme_AA",
//   // E: "viseme_O",
//   // F: "viseme_U",
//   // G: "viseme_FF",
//   // H: "viseme_TH",
//   // X: "viseme_PP",

//   // P: "viseme_PP",
//   // B: "viseme_PP",
//   // M: "viseme_PP",
//   // F: "viseme_FF",
//   // V: "viseme_FF",
//   // TH: "viseme_TH",
//   // D: "viseme_DD",
//   // T: "viseme_DD",
//   // N: "viseme_DD",
//   // K: "viseme_kk",
//   // G: "viseme_kk",
//   // NG: "viseme_kk",
//   // CH: "viseme_CH",
//   // J: "viseme_CH",
//   // SH: "viseme_CH",
//   // S: "viseme_SS",
//   // Z: "viseme_SS",
//   // L: "viseme_nn",
//   // R: "viseme_RR",
//   // AA: "viseme_aa",
//   // E: "viseme_E",
//   // I: "viseme_I",
//   // O: "viseme_O",
//   // U: "viseme_U",
//   // SIL: "viseme_sil",

//   X: "viseme_PP",
//   P: "viseme_PP",
//   B: "viseme_PP",
//   M: "viseme_PP",
//   F: "viseme_FF",
//   V: "viseme_FF",
//   TH: "viseme_TH",
//   D: "viseme_DD",
//   T: "viseme_DD",
//   N: "viseme_DD",
//   K: "viseme_kk",
//   G: "viseme_kk",
//   NG: "viseme_kk",
//   CH: "viseme_CH",
//   J: "viseme_CH",
//   SH: "viseme_CH",
//   S: "viseme_SS",
//   Z: "viseme_SS",
//   L: "viseme_nn",
//   R: "viseme_RR",
//   AA: "viseme_aa",
//   E: "viseme_E",
//   I: "viseme_I",
//   O: "viseme_O",
//   U: "viseme_U",
//   SIL: "viseme_sil",
//   TH_: "viseme_TH_", // for "th" in "this" or "that"
//   CH_: "viseme_CH_", // for "ch" in "church" or "change"
//   A_CAT: "viseme_A_CAT", // for "a" in "cat"
//   A_FACE: "viseme_A_FACE", // for "a" in "face"
// };

// export function Avatar(props) {
//   const { responseData } = useSpeechRecognition1();
//   const [cues, setCues] = useState([]);
//   const utteranceRef = useRef(null);
//   const startTimeRef = useRef(0);
//   const speechSynthesisRef = useRef(null);
//   const [audioUrl, setAudioUrl] = useState("");
//   const audioRef = useRef(null);

//   const smoothMorphTarget = true;
//   const morphTargetSmoothing = 0.5;

//   useEffect(() => {
//     const params = {
//       OutputFormat: "mp3",
//       Text: responseData,
//       VoiceId: "Brian",
//     };

//     polly.synthesizeSpeech(params, (err, data) => {
//       if (err) {
//         console.log("Error synthesizing speech:", err);
//       } else {
//         const audioContent = Buffer.from(data.AudioStream).toString("base64");
//         const audioUrl = `data:audio/mp3;base64,${audioContent}`;
//         setAudioUrl(audioUrl);
//       }
//     });
//   }, [responseData]);

//   useEffect(() => {
//     if (audioUrl) {
//       audioRef.current = new Audio(audioUrl);
//       audioRef.current.play();
//     }
//   }, [audioUrl]);

//   useEffect(() => {
//     if ("speechSynthesis" in window) {
//       speechSynthesisRef.current = window.speechSynthesis;
//     }
//   }, []);

//   useEffect(() => {
//     if (responseData) {
//       const utterance = new SpeechSynthesisUtterance(responseData);
//       utteranceRef.current = utterance;
//       const generatedCues = [];
//       console.log("utterance", utterance);
//       utterance.onboundary = (event) => {
//         if (event.name === "word") {
//           const charIndex = event.charIndex;
//           const charLength = event.charLength;
//           const text = utterance.text;
//           const chars = [];

//           for (let i = charIndex; i < charIndex + charLength; i++) {
//             const char = text.charAt(i);
//             chars.push(char);
//           }

//           chars.forEach((char) => {
//             const start = event.elapsedTime * 1000; // Convert to milliseconds
//             const end = (event.elapsedTime + 0.2) * 1000; // Convert to milliseconds
//             const viseme = corresponding[char.toUpperCase()] || "X";

//             generatedCues.push({
//               value: viseme,
//               start,
//               end,
//             });
//           });

//           // Update the current time of the speech synthesis
//           startTimeRef.current = event.elapsedTime * 1000;
//         }
//       };

//       // speechSynthesisRef.current.speak(utterance);

//       utterance.onstart = () => {
//         setCues(generatedCues);
//         console.log("Cues:", generatedCues);
//       };
//     }
//   }, [responseData]);

//   const { nodes, materials } = useGLTF("/models/667d2dc7ab338d43c837c83c.glb");

//   useFrame(() => {
//     if (speechSynthesisRef.current && speechSynthesisRef.current.speaking) {
//       const currentTime = startTimeRef.current;
//       console.log(currentTime);

//       // Object.values(corresponding).forEach((value) => {
//       //   nodes.Wolf3D_Head.morphTargetInfluences[
//       //     nodes.Wolf3D_Head.morphTargetDictionary[value]
//       //   ] = 0;

//       //   nodes.Wolf3D_Teeth.morphTargetInfluences[
//       //     nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//       //   ] = 0;
//       // });

//       Object.values(corresponding).forEach((value) => {
//         if (!smoothMorphTarget) {
//           nodes.Wolf3D_Head.morphTargetInfluences[
//             nodes.Wolf3D_Head.morphTargetDictionary[value]
//           ] = 0;
//           nodes.Wolf3D_Teeth.morphTargetInfluences[
//             nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//           ] = 0;
//         } else {
//           nodes.Wolf3D_Head.morphTargetInfluences[
//             nodes.Wolf3D_Head.morphTargetDictionary[value]
//           ] = THREE.MathUtils.lerp(
//             nodes.Wolf3D_Head.morphTargetInfluences[
//               nodes.Wolf3D_Head.morphTargetDictionary[value]
//             ],
//             0,
//             morphTargetSmoothing
//           );

//           nodes.Wolf3D_Teeth.morphTargetInfluences[
//             nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//           ] = THREE.MathUtils.lerp(
//             nodes.Wolf3D_Teeth.morphTargetInfluences[
//               nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//             ],
//             0,
//             morphTargetSmoothing
//           );
//         }
//       });

//       for (let i = 0; i < cues.length; i++) {
//         const mouthCue = cues[i];
//         const startTime = mouthCue.start;
//         const endTime = mouthCue.end;

//         if (currentTime >= startTime && currentTime <= endTime) {
//           const viseme = mouthCue.value;

//           nodes.Wolf3D_Head.morphTargetInfluences[
//             nodes.Wolf3D_Head.morphTargetDictionary[viseme]
//           ] = 1;

//           nodes.Wolf3D_Teeth.morphTargetInfluences[
//             nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
//           ] = 1;
//           break;
//         }
//       }

//       // for (let i = 0; i < cues.length; i++) {
//       //   const mouthCue = cues[i];
//       //   const startTime = mouthCue.start;
//       //   const endTime = mouthCue.end;
//       //   if (currentTime >= startTime && currentTime <= endTime) {
//       //     if (!smoothMorphTarget) {
//       //       nodes.Wolf3D_Head.morphTargetInfluences[
//       //         nodes.Wolf3D_Head.morphTargetDictionary[
//       //           corresponding[mouthCue.value]
//       //         ]
//       //       ] = 1;
//       //       nodes.Wolf3D_Teeth.morphTargetInfluences[
//       //         nodes.Wolf3D_Teeth.morphTargetDictionary[
//       //           corresponding[mouthCue.value]
//       //         ]
//       //       ] = 1;
//       //     } else {
//       //       nodes.Wolf3D_Head.morphTargetInfluences[
//       //         nodes.Wolf3D_Head.morphTargetDictionary[
//       //           corresponding[mouthCue.value]
//       //         ]
//       //       ] = THREE.MathUtils.lerp(
//       //         nodes.Wolf3D_Head.morphTargetInfluences[
//       //           nodes.Wolf3D_Head.morphTargetDictionary[
//       //             corresponding[mouthCue.value]
//       //           ]
//       //         ],
//       //         1,
//       //         morphTargetSmoothing
//       //       );
//       //       nodes.Wolf3D_Teeth.morphTargetInfluences[
//       //         nodes.Wolf3D_Teeth.morphTargetDictionary[
//       //           corresponding[mouthCue.value]
//       //         ]
//       //       ] = THREE.MathUtils.lerp(
//       //         nodes.Wolf3D_Teeth.morphTargetInfluences[
//       //           nodes.Wolf3D_Teeth.morphTargetDictionary[
//       //             corresponding[mouthCue.value]
//       //           ]
//       //         ],
//       //         1,
//       //         morphTargetSmoothing
//       //       );
//       //     }

//       //     break;
//       //   }
//       // }
//     } else {
//       Object.values(corresponding).forEach((value) => {
//         if (!smoothMorphTarget) {
//           nodes.Wolf3D_Head.morphTargetInfluences[
//             nodes.Wolf3D_Head.morphTargetDictionary[value]
//           ] = 0;
//           nodes.Wolf3D_Teeth.morphTargetInfluences[
//             nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//           ] = 0;
//         } else {
//           nodes.Wolf3D_Head.morphTargetInfluences[
//             nodes.Wolf3D_Head.morphTargetDictionary[value]
//           ] = THREE.MathUtils.lerp(
//             nodes.Wolf3D_Head.morphTargetInfluences[
//               nodes.Wolf3D_Head.morphTargetDictionary[value]
//             ],
//             0,
//             morphTargetSmoothing
//           );

//           nodes.Wolf3D_Teeth.morphTargetInfluences[
//             nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//           ] = THREE.MathUtils.lerp(
//             nodes.Wolf3D_Teeth.morphTargetInfluences[
//               nodes.Wolf3D_Teeth.morphTargetDictionary[value]
//             ],
//             0,
//             morphTargetSmoothing
//           );
//         }
//       });
//     }
//   });

//   return (
//     <group {...props} dispose={null}>
//       <primitive object={nodes.Hips} />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Glasses.geometry}
//         material={materials.Wolf3D_Glasses}
//         skeleton={nodes.Wolf3D_Glasses.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Headwear.geometry}
//         material={materials.Wolf3D_Headwear}
//         skeleton={nodes.Wolf3D_Headwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Body.geometry}
//         material={materials.Wolf3D_Body}
//         skeleton={nodes.Wolf3D_Body.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//         material={materials.Wolf3D_Outfit_Bottom}
//         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//         material={materials.Wolf3D_Outfit_Footwear}
//         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//         material={materials.Wolf3D_Outfit_Top}
//         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//       />
//       <skinnedMesh
//         name="EyeLeft"
//         geometry={nodes.EyeLeft.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeLeft.skeleton}
//         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="EyeRight"
//         geometry={nodes.EyeRight.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeRight.skeleton}
//         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Head"
//         geometry={nodes.Wolf3D_Head.geometry}
//         material={materials.Wolf3D_Skin}
//         skeleton={nodes.Wolf3D_Head.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Teeth"
//         geometry={nodes.Wolf3D_Teeth.geometry}
//         material={materials.Wolf3D_Teeth}
//         skeleton={nodes.Wolf3D_Teeth.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//       />
//     </group>
//   );
// }

// useGLTF.preload("/models/667d2dc7ab338d43c837c83c.glb");

// import React, { useState, useEffect, useRef } from "react";
// import { useGLTF } from "@react-three/drei";
// import { useFrame } from "@react-three/fiber";
// import useSpeechRecognition1 from "../hooks/useSpeechToText/index";
// import * as THREE from "three";
// import { Polly } from "aws-sdk";
// import { Buffer } from "buffer";
// // import dotenv from "dotenv";
// // import * as path from "path";
// // dotenv.config();

// const polly = new Polly({
//   credentials: {
//     accessKeyId: "AKIASLWIJDRLMW46KAFQ",
//     secretAccessKey: "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",
//   },
//   region: "ap-south-1",
// });

// // Define phonemes with corresponding viseme mappings
// const phonemes = {
//   X: "viseme_PP",
//   P: "viseme_PP",
//   B: "viseme_PP",
//   M: "viseme_PP",
//   F: "viseme_FF",
//   V: "viseme_FF",
//   TH: "viseme_TH",
//   D: "viseme_DD",
//   T: "viseme_DD",
//   N: "viseme_DD",
//   K: "viseme_kk",
//   G: "viseme_kk",
//   NG: "viseme_kk",
//   CH: "viseme_CH",
//   J: "viseme_CH",
//   SH: "viseme_CH",
//   S: "viseme_SS",
//   Z: "viseme_SS",
//   L: "viseme_nn",
//   R: "viseme_RR",
//   AA: "viseme_aa",
//   E: "viseme_E",
//   I: "viseme_I",
//   O: "viseme_O",
//   U: "viseme_U",
//   SIL: "viseme_sil",
//   TH_: "viseme_TH_", // for "th" in "this" or "that"
//   CH_: "viseme_CH_", // for "ch" in "church" or "change"
//   A_CAT: "viseme_A_CAT", // for "a" in "cat"
//   A_FACE: "viseme_A_FACE", // for "a" in "face"
// };

// // Function to simulate phoneme extraction from text (replace with actual implementation)
// function getPhonemesFromText(text) {
//   // Example: Splitting text into individual words for simplicity
//   const words = text.split(" ");
//   const phonemesList = [];

//   words.forEach((word) => {
//     // Dummy phoneme assignment based on simple rules
//     if (word === "hello") {
//       phonemesList.push("H", "EH", "L", "OH");
//     } else if (word === "world") {
//       phonemesList.push("W", "ER", "L", "D");
//     }
//     // Add more cases as per your requirement
//   });

//   return phonemesList;
// }

// // Function to map phonemes to visemes
// function getVisemeFromPhoneme(phoneme) {
//   return phonemes[phoneme] || "default_viseme"; // Return default viseme if not found
// }

// export function Avatar(props) {
//   const { responseData } = useSpeechRecognition1();
//   // const [cues, setCues] = useState([]);
//   // const utteranceRef = useRef(null);
//   // const startTimeRef = useRef(0);
//   // const speechSynthesisRef = useRef(null);
//   // const smoothMorphTarget = true;
//   // const morphTargetSmoothing = 0.5;

//   const [audioUrl, setAudioUrl] = useState("");
//   const [mouthMovements, setMouthMovements] = useState([]);
//   const avatarModelRef = useRef(null);
//   const mixer = useRef(null);
//   const [audioBuffer, setAudioBuffer] = useState([]);

//   useEffect(() => {
//     const params = {
//       OutputFormat: "mp3",
//       Text: responseData,
//       VoiceId: "Joanna", // or any other voice ID
//     };

//     polly.synthesizeSpeech(params, (err, data) => {
//       if (err) {
//         console.log("Error synthesizing speech:", err);
//       } else {
//         console.log("audio ", data);
//         const audioContent = Buffer.from(data.AudioStream).toString("base64");
//         const audioUrl = `data:audio/mp3;base64,${audioContent}`; // Corrected here
//         setAudioUrl(audioUrl);
//         // console.log("audioUrl", audioUrl);
//       }
//     });
//   }, [responseData]);

//   useEffect(() => {
//     console.log("viseme");

//     const ssml = `
//       <speak>
//         <p>${responseData.replace(
//           /"/g,
//           (match) => `<say-as interpret-as="characters">${match}</say-as>`
//         )}</p>
//       </speak>
//     `;

//     console.log("ssml", ssml);

//     const visemeParams = {
//       OutputFormat: "json",
//       SampleRate: "22050",
//       Text: ssml,
//       TextType: "ssml",
//       VoiceId: "Joanna",
//       SpeechMarkTypes: ["viseme"],
//     };

//     polly.synthesizeSpeech(visemeParams, (err, data) => {
//       if (err) {
//         console.log("err", err);
//       } else {
//         const jsonStr = Buffer.from(data.AudioStream).toString("utf8");

//         try {
//           if (jsonStr) {
//             const jsonArray = jsonStr
//               .trim()
//               .split("\n")
//               .map((line) => JSON.parse(line));

//             setAudioBuffer(jsonArray);
//           }
//         } catch (error) {
//           console.error("Error parsing JSON:", error);
//         }
//       }
//     });
//   }, [responseData]);

//   useEffect(() => {
//     if (audioUrl) {
//       const phonemesList = audioBuffer; // Simulated phoneme extraction
//       const calculatedMouthMovements = phonemesList.map((phoneme, index) => ({
//         viseme: getVisemeFromPhoneme(phoneme),
//         timestamp: index * 0.1, // Adjust timing as needed
//       }));
//       setMouthMovements(calculatedMouthMovements);
//       console.log("calculatedMouthMovements", calculatedMouthMovements);
//     }
//   }, [audioUrl, responseData]);

//   const { nodes, materials } = useGLTF("/models/667d2dc7ab338d43c837c83c.glb");

//   useFrame((_, delta) => {
//     if (avatarModelRef.current && mouthMovements.length > 0) {
//       if (!mixer.current) {
//         mixer.current = new THREE.AnimationMixer(avatarModelRef.current);
//       }

//       const clips = mouthMovements.map((movement, index) => {
//         const clip = THREE.AnimationClip.create("MouthAnimation" + index, 1, [
//           THREE.AnimationUtils.makeClipSegment(
//             getMorphTargetInfluences(movement.mouthMovement),
//             movement.timestamp,
//             delta
//           ),
//         ]);
//         return clip;
//       });

//       clips.forEach((clip) => {
//         const action = mixer.current.clipAction(clip);
//         action.play();
//       });
//     }
//   });

//   return (
//     <group {...props} dispose={null}>
//       <primitive object={nodes.Hips} />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Glasses.geometry}
//         material={materials.Wolf3D_Glasses}
//         skeleton={nodes.Wolf3D_Glasses.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Headwear.geometry}
//         material={materials.Wolf3D_Headwear}
//         skeleton={nodes.Wolf3D_Headwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Body.geometry}
//         material={materials.Wolf3D_Body}
//         skeleton={nodes.Wolf3D_Body.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//         material={materials.Wolf3D_Outfit_Bottom}
//         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//         material={materials.Wolf3D_Outfit_Footwear}
//         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//         material={materials.Wolf3D_Outfit_Top}
//         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//       />
//       <skinnedMesh
//         name="EyeLeft"
//         geometry={nodes.EyeLeft.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeLeft.skeleton}
//         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="EyeRight"
//         geometry={nodes.EyeRight.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeRight.skeleton}
//         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Head"
//         geometry={nodes.Wolf3D_Head.geometry}
//         material={materials.Wolf3D_Skin}
//         skeleton={nodes.Wolf3D_Head.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Teeth"
//         geometry={nodes.Wolf3D_Teeth.geometry}
//         material={materials.Wolf3D_Teeth}
//         skeleton={nodes.Wolf3D_Teeth.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//       />
//     </group>
//   );
// }

// function getMouthMovementFromPhoneme(phoneme) {
//   switch (phoneme) {
//     case "ah":
//       return "open-mouth"; // Example: Open mouth animation
//     case "oh":
//       return "rounded-mouth"; // Example: Rounded mouth animation
//     default:
//       return "neutral-mouth"; // Default mouth state
//   }
// }

// function getMorphTargetInfluences(mouthMovement) {
//   switch (mouthMovement) {
//     case "open-mouth":
//       return [1, 0, 0]; // Adjust based on your morph target influences
//     case "rounded-mouth":
//       return [0, 1, 0]; // Adjust based on your morph target influences
//     default:
//       return [0, 0, 1]; // Default neutral state
//   }
// }

// useGLTF.preload("/models/667d2dc7ab338d43c837c83c.glb");

// import React, { useState, useEffect, useRef, useLayoutEffect } from "react";
// import { useGLTF } from "@react-three/drei";
// import { useFrame } from "@react-three/fiber";
// import useSpeechRecognition1 from "../hooks/useSpeechToText/index";
// import * as THREE from "three";
// import { Polly } from "aws-sdk";
// import { Buffer } from "buffer";

// const polly = new Polly({
//   credentials: {
//     accessKeyId: "AKIASLWIJDRLMW46KAFQ",
//     secretAccessKey: "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",
//   },
//   region: "ap-south-1",
// });

// const phonemes = {
//   X: "viseme_PP",
//   P: "viseme_PP",
//   B: "viseme_PP",
//   M: "viseme_PP",
//   F: "viseme_FF",
//   V: "viseme_FF",
//   TH: "viseme_TH",
//   D: "viseme_DD",
//   T: "viseme_DD",
//   N: "viseme_DD",
//   K: "viseme_kk",
//   G: "viseme_kk",
//   NG: "viseme_kk",
//   CH: "viseme_CH",
//   J: "viseme_CH",
//   SH: "viseme_CH",
//   S: "viseme_SS",
//   Z: "viseme_SS",
//   L: "viseme_nn",
//   R: "viseme_RR",
//   AA: "viseme_aa",
//   E: "viseme_E",
//   I: "viseme_I",
//   O: "viseme_O",
//   U: "viseme_U",
//   SIL: "viseme_sil",
//   TH_: "viseme_TH_", // for "th" in "this" or "that"
//   CH_: "viseme_CH_", // for "ch" in "church" or "change"
//   A_CAT: "viseme_A_CAT", // for "a" in "cat"
//   A_FACE: "viseme_A_FACE", // for "a" in "face"
// };

// function getVisemeFromPhoneme(phoneme) {
//   return phonemes[phoneme] || "default_viseme";
// }

// export function Avatar(props) {
//   const { responseData } = useSpeechRecognition1();
//   const [audioUrl, setAudioUrl] = useState("");
//   const [mouthMovements, setMouthMovements] = useState([]);
//   const avatarModelRef = useRef(null);
//   const mixer = useRef(null);
//   const audioRef = useRef(null);
//   const animationClipRef = useRef(null);
//   const mixerRef = useRef(null);
//   const [visemeData, setVisemeData] = useState([]);

//   const startTimeRef = useRef(0);

//   useEffect(() => {
//     const params = {
//       OutputFormat: "mp3",
//       Text: responseData,
//       VoiceId: "Brian",
//     };

//     polly.synthesizeSpeech(params, (err, data) => {
//       if (err) {
//         console.log("Error synthesizing speech:", err);
//       } else {
//         const audioContent = Buffer.from(data.AudioStream).toString("base64");
//         const audioUrl = `data:audio/mp3;base64,${audioContent}`;
//         setAudioUrl(audioUrl);
//       }
//     });
//   }, [responseData]);

//   useEffect(() => {
//     const ssml = `
//       <speak>
//         <p>${responseData.replace(
//           /"/g,
//           (match) => `<say-as interpret-as="characters">${match}</say-as>`
//         )}</p>
//       </speak>
//     `;

//     const visemeParams = {
//       OutputFormat: "json",
//       SampleRate: "22050",
//       Text: ssml,
//       TextType: "ssml",
//       VoiceId: "Brian",
//       SpeechMarkTypes: ["viseme"],
//     };

//     polly.synthesizeSpeech(visemeParams, (err, data) => {
//       if (err) {
//         console.log("err", err);
//       } else {
//         const jsonStr = Buffer.from(data.AudioStream).toString("utf8");

//         if (jsonStr) {
//           const visemeData = jsonStr
//             .trim()
//             .split("\n")
//             .map((line) => JSON.parse(line));

//           console.log("visemeData: ", visemeData);
//           const mouthMovements = visemeData.map((viseme, index) => ({
//             viseme: getVisemeFromPhoneme(viseme.value.toUpperCase()),
//             timestamp: viseme.time,
//           }));
//           setMouthMovements(mouthMovements);
//         }
//       }
//     });
//   }, [responseData]);

//   useEffect(() => {
//     if (audioUrl) {
//       audioRef.current = new Audio(audioUrl);
//       audioRef.current.play();
//       avatarModelRef.current = nodes.Wolf3D_Head;
//     }
//   }, [audioUrl]);

//   const { nodes, materials } = useGLTF("/models/667d2dc7ab338d43c837c83c.glb");

//   // function getMorphTargetIndex(viseme) {
//   //   const morphTargetInfluences = nodes.Wolf3D_Head.morphTargetInfluences;
//   //   const morphTargetDictionary = nodes.Wolf3D_Head.morphTargetDictionary;

//   //   console.log("viseme", viseme);
//   //   console.log("influenc", morphTargetInfluences);
//   //   console.log("Morph target dictionary:", morphTargetDictionary);

//   //   for (let i = 0; i < morphTargetInfluences.length; i++) {
//   //     console.log("morphTargetDictionary[i]", morphTargetDictionary[i]);
//   //     if (morphTargetDictionary[i] == viseme) {
//   //       return i;
//   //     }
//   //   }

//   //   return -1; // Return -1 if the viseme is not found
//   // }

//   // useFrame((_, delta) => {
//   //   // console.log("frame");
//   //   // console.log("mouthMovements", mouthMovements.length);
//   //   // console.log("avatarModelRef.current ", avatarModelRef.current);
//   //   if (avatarModelRef.current && mouthMovements.length > 0) {
//   //     if (!mixer.current) {
//   //       mixer.current = new THREE.AnimationMixer(avatarModelRef.current);
//   //     }

//   //     const clips = mouthMovements.map((movement, index) => {
//   //       const clip = THREE.AnimationClip.create("MouthAnimation" + index, 1, [
//   //         // THREE.AnimationUtils.makeClipSegment(
//   //         getMorphTargetInfluences(movement.viseme),
//   //         movement.timestamp,
//   //         // delta
//   //         // ),
//   //       ]);
//   //       return clip;
//   //     });

//   //     clips.forEach((clip) => {
//   //       const action = mixer.current.clipAction(clip);
//   //       action.play();
//   //     });
//   //   }
//   // });

//   // useFrame((_, delta) => {
//   //   if (avatarModelRef.current && mouthMovements.length > 0) {
//   //     if (!mixer.current) {
//   //       mixer.current = new THREE.AnimationMixer(avatarModelRef.current);
//   //     }

//   //     mouthMovements.forEach((movement, index) => {
//   //       // console.log("inside for");
//   //       const morphTargetInfluences = nodes.Wolf3D_Head.morphTargetInfluences;

//   //       // Determine the index of the morph target based on the viseme
//   //       const morphTargetIndex = getMorphTargetIndex(movement.viseme);

//   //       // console.log("morphTargetIndex", morphTargetIndex);

//   //       if (morphTargetIndex !== -1) {
//   //         // console.log("inside if");
//   //         const track = new THREE.NumberKeyframeTrack(
//   //           `.morphTargetInfluences[${morphTargetIndex}]`,
//   //           [0, 1],
//   //           [0, 1] // Set the influence to 1 at timestamp 1
//   //         );
//   //         // console.log("track", track);
//   //         const clip = new THREE.AnimationClip("MouthAnimation" + index, 1, [
//   //           track,
//   //         ]);
//   //         const action = mixer.current.clipAction(clip);
//   //         action.play();
//   //       }
//   //     });
//   //   }
//   // });

//   //   function getMorphTargetIndex(viseme) {
//   //     const morphTargetDictionary = nodes.Wolf3D_Head.morphTargetDictionary;
//   //     const keys = Object.keys(morphTargetDictionary);
//   //     const index = keys.indexOf(viseme);
//   //     return index !== -1 ? morphTargetDictionary[viseme] : -1;
//   //   }

//   //   useFrame((_, delta) => {
//   //     if (avatarModelRef.current && mouthMovements.length > 0) {
//   //       if (!mixer.current) {
//   //         mixer.current = new THREE.AnimationMixer(avatarModelRef.current);
//   //       }

//   //       const times = [];
//   //       const values = [];

//   //       console.log("mouthMovements", mouthMovements);

//   //       mouthMovements.forEach((movement, index) => {
//   //         const morphTargetIndex = getMorphTargetIndex(movement.viseme);

//   //         if (morphTargetIndex !== -1) {
//   //           console.log("morphTargetIndex", morphTargetIndex);

//   //           times.push(movement.timestamp);
//   //           values.push(1);
//   //           times.push(movement.timestamp + 0.1);
//   //           values.push(0);
//   //         }
//   //       });

//   //       mouthMovements.forEach((movement, index) => {
//   //         const morphTargetIndex = getMorphTargetIndex(movement.viseme);
//   //         if (morphTargetIndex !== -1) {
//   //           console.log("morph Target Index 2", morphTargetIndex);

//   //           console.log("times", times);
//   //           console.log("values", values);

//   //           const track = new THREE.NumberKeyframeTrack(
//   //             `.morphTargetInfluences[${morphTargetIndex}]`,
//   //             times,
//   //             values
//   //           );

//   //           console.log("track", track);

//   //           const clip = new THREE.AnimationClip("MouthAnimation", 1, [track]);

//   //           console.log("clip", clip);

//   //           // const action = mixer.current.clipAction(clip);
//   //           // action.play();
//   //           const action = mixer.current.clipAction(clip);
//   //           action.play();
//   //           mixer.current.update(delta);
//   //         }
//   //       });
//   //     }
//   //   });

//   //   return (
//   //     <group {...props} dispose={null}>
//   //       <primitive object={nodes.Hips} />
//   //       <skinnedMesh
//   //         geometry={nodes.Wolf3D_Glasses.geometry}
//   //         material={materials.Wolf3D_Glasses}
//   //         skeleton={nodes.Wolf3D_Glasses.skeleton}
//   //       />
//   //       <skinnedMesh
//   //         geometry={nodes.Wolf3D_Headwear.geometry}
//   //         material={materials.Wolf3D_Headwear}
//   //         skeleton={nodes.Wolf3D_Headwear.skeleton}
//   //       />
//   //       <skinnedMesh
//   //         geometry={nodes.Wolf3D_Body.geometry}
//   //         material={materials.Wolf3D_Body}
//   //         skeleton={nodes.Wolf3D_Body.skeleton}
//   //       />
//   //       <skinnedMesh
//   //         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//   //         material={materials.Wolf3D_Outfit_Bottom}
//   //         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//   //       />
//   //       <skinnedMesh
//   //         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//   //         material={materials.Wolf3D_Outfit_Footwear}
//   //         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//   //       />
//   //       <skinnedMesh
//   //         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//   //         material={materials.Wolf3D_Outfit_Top}
//   //         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//   //       />
//   //       <skinnedMesh
//   //         name="EyeLeft"
//   //         geometry={nodes.EyeLeft.geometry}
//   //         material={materials.Wolf3D_Eye}
//   //         skeleton={nodes.EyeLeft.skeleton}
//   //         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//   //         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//   //       />
//   //       <skinnedMesh
//   //         name="EyeRight"
//   //         geometry={nodes.EyeRight.geometry}
//   //         material={materials.Wolf3D_Eye}
//   //         skeleton={nodes.EyeRight.skeleton}
//   //         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//   //         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//   //       />
//   //       <skinnedMesh
//   //         name="Wolf3D_Head"
//   //         geometry={nodes.Wolf3D_Head.geometry}
//   //         material={materials.Wolf3D_Skin}
//   //         skeleton={nodes.Wolf3D_Head.skeleton}
//   //         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//   //         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//   //         ref={avatarModelRef}
//   //       />
//   //       <skinnedMesh
//   //         name="Wolf3D_Teeth"
//   //         geometry={nodes.Wolf3D_Teeth.geometry}
//   //         material={materials.Wolf3D_Teeth}
//   //         skeleton={nodes.Wolf3D_Teeth.skeleton}
//   //         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//   //         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//   //         ref={avatarModelRef}
//   //       />
//   //     </group>
//   //   );
//   // }

//   // function getMorphTargetInfluences(mouthMovement) {
//   //   switch (mouthMovement) {
//   //     case "open-mouth":
//   //       return [1, 0, 0]; // Adjust based on your morph target influences
//   //     case "rounded-mouth":
//   //       return [0, 1, 0]; // Adjust based on your morph target influences
//   //     default:
//   //       return [0, 0, 1]; // Default neutral state
//   //   }
//   // }

//   function getMorphTargetIndex(viseme) {
//     const morphTargetDictionary = nodes.Wolf3D_Head.morphTargetDictionary;
//     return morphTargetDictionary[viseme] ?? -1;
//   }

//   // useFrame((_, delta) => {
//   //   console.log("avatarModelRef: ", avatarModelRef.current);
//   //   if (avatarModelRef.current && mouthMovements.length > 0) {
//   //     if (!mixer.current) {
//   //       mixer.current = new THREE.AnimationMixer(avatarModelRef.current);
//   //     }

//   //     const times = [];
//   //     const values = [];

//   //     let currentTime = 0;
//   //     mouthMovements.forEach((movement) => {
//   //       const morphTargetIndex = getMorphTargetIndex(movement.viseme);

//   //       if (morphTargetIndex !== -1) {
//   //         times.push(currentTime);
//   //         values.push(1);
//   //         times.push(currentTime + 0.05); // adjust the duration of the mouth movement
//   //         values.push(0);
//   //       }

//   //       currentTime += movement.duration; // update the current time based on the duration of the mouth movement
//   //     });

//   //     if (times.length > 0 && values.length > 0) {
//   //       const track = new THREE.NumberKeyframeTrack(
//   //         `.morphTargetInfluences[${getMorphTargetIndex(
//   //           mouthMovements[0].viseme
//   //         )}]`,
//   //         times,
//   //         values
//   //       );

//   //       const clip = new THREE.AnimationClip("MouthAnimation", -1, [track]);

//   //       if (mixer.current.clipAction(clip)) {
//   //         mixer.current.clipAction(clip).stop();
//   //       }

//   //       const action = mixer.current.clipAction(clip);
//   //       action.play();

//   //       mixer.current.update(delta);
//   //     }
//   //   }
//   // });

//   // useFrame((_, delta) => {
//   //   if (avatarModelRef.current && mouthMovements.length > 0) {
//   //     if (!mixer.current) {
//   //       mixer.current = new THREE.AnimationMixer(avatarModelRef.current);
//   //     }

//   //     let currentTime = 0;

//   //     mouthMovements.forEach((movement, index) => {
//   //       const morphTargetIndex = getMorphTargetIndex(movement.viseme);

//   //       if (morphTargetIndex !== -1) {
//   //         const times = [currentTime, currentTime + 0.05]; // adjust the duration of the mouth movement
//   //         const values = [1, 0];

//   //         const track = new THREE.NumberKeyframeTrack(
//   //           `.morphTargetInfluences[${morphTargetIndex}]`,
//   //           times,
//   //           values
//   //         );

//   //         const clip = new THREE.AnimationClip(
//   //           `MouthAnimation_${movement.viseme}`,
//   //           -1,
//   //           [track]
//   //         );

//   //         if (mixer.current.clipAction(clip)) {
//   //           mixer.current.clipAction(clip).stop();
//   //         }

//   //         const action = mixer.current.clipAction(clip);
//   //         action.play();

//   //         currentTime += 0.05; // update the current time based on the duration of the mouth movement
//   //       }
//   //     });

//   //     mixer.current.update(delta);
//   //   }
//   // });

//   // useLayoutEffect(() => {
//   //   avatarModelRef.current = nodes.Wolf3D_Head;
//   // }, [nodes]);

//   useFrame(() => {
//     const currentTime = performance.now() / 1000 - startTimeRef.current;
//     visemeData.forEach((cue) => {
//       const { viseme, timestamp } = cue;
//       const endTime = timestamp + 0.05; // Duration for viseme

//       if (currentTime >= timestamp && currentTime <= endTime) {
//         const morphIndex = nodes.Wolf3D_Head.morphTargetDictionary[viseme];
//         if (morphIndex !== undefined) {
//           nodes.Wolf3D_Head.morphTargetInfluences[morphIndex] =
//             THREE.MathUtils.lerp(
//               nodes.Wolf3D_Head.morphTargetInfluences[morphIndex],
//               1,
//               0.1
//             );
//           nodes.Wolf3D_Teeth.morphTargetInfluences[morphIndex] =
//             THREE.MathUtils.lerp(
//               nodes.Wolf3D_Teeth.morphTargetInfluences[morphIndex],
//               1,
//               0.1
//             );
//         }
//       } else {
//         const morphIndex = nodes.Wolf3D_Head.morphTargetDictionary[viseme];
//         if (morphIndex !== undefined) {
//           nodes.Wolf3D_Head.morphTargetInfluences[morphIndex] =
//             THREE.MathUtils.lerp(
//               nodes.Wolf3D_Head.morphTargetInfluences[morphIndex],
//               0,
//               0.1
//             );
//           nodes.Wolf3D_Teeth.morphTargetInfluences[morphIndex] =
//             THREE.MathUtils.lerp(
//               nodes.Wolf3D_Teeth.morphTargetInfluences[morphIndex],
//               0,
//               0.1
//             );
//         }
//       }
//     });
//   });

//   return (
//     <group {...props} dispose={null}>
//       <primitive object={nodes.Hips} />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Glasses.geometry}
//         material={materials.Wolf3D_Glasses}
//         skeleton={nodes.Wolf3D_Glasses.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Headwear.geometry}
//         material={materials.Wolf3D_Headwear}
//         skeleton={nodes.Wolf3D_Headwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Body.geometry}
//         material={materials.Wolf3D_Body}
//         skeleton={nodes.Wolf3D_Body.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
//         material={materials.Wolf3D_Outfit_Bottom}
//         skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
//         material={materials.Wolf3D_Outfit_Footwear}
//         skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
//       />
//       <skinnedMesh
//         geometry={nodes.Wolf3D_Outfit_Top.geometry}
//         material={materials.Wolf3D_Outfit_Top}
//         skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
//       />
//       <skinnedMesh
//         name="EyeLeft"
//         geometry={nodes.EyeLeft.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeLeft.skeleton}
//         morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="EyeRight"
//         geometry={nodes.EyeRight.geometry}
//         material={materials.Wolf3D_Eye}
//         skeleton={nodes.EyeRight.skeleton}
//         morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
//         morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
//       />
//       <skinnedMesh
//         name="Wolf3D_Head"
//         geometry={nodes.Wolf3D_Head.geometry}
//         material={materials.Wolf3D_Skin}
//         skeleton={nodes.Wolf3D_Head.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
//         ref={avatarModelRef}
//       />
//       <skinnedMesh
//         name="Wolf3D_Teeth"
//         geometry={nodes.Wolf3D_Teeth.geometry}
//         material={materials.Wolf3D_Teeth}
//         skeleton={nodes.Wolf3D_Teeth.skeleton}
//         morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
//         morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
//       />
//     </group>
//   );
// }

import React, { useState, useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useSpeechRecognitionContext } from "../hooks/useSpeechToText";
import * as THREE from "three";
import { Polly } from "aws-sdk";
import { Buffer } from "buffer";

const polly = new Polly({
  credentials: {
    accessKeyId: process.env.REACT_APP_ACCESS_KEY_ID,
    secretAccessKey: process.env.REACT_APP_SECRET_ACCESS_KEY,
  },
  region: process.env.REACT_APP_REGION,
});

const corresponding = {
  X: "viseme_PP",
  P: "viseme_PP",
  B: "viseme_PP",
  M: "viseme_PP",
  F: "viseme_FF",
  V: "viseme_FF",
  TH: "viseme_TH",
  D: "viseme_DD",
  T: "viseme_DD",
  N: "viseme_DD",
  K: "viseme_kk",
  G: "viseme_kk",
  NG: "viseme_kk",
  CH: "viseme_CH",
  J: "viseme_CH",
  SH: "viseme_CH",
  S: "viseme_SS",
  Z: "viseme_SS",
  L: "viseme_nn",
  R: "viseme_RR",
  AA: "viseme_aa",
  E: "viseme_E",
  I: "viseme_I",
  O: "viseme_O",
  U: "viseme_U",
  SIL: "viseme_sil",
  TH_: "viseme_TH_", // for "th" in "this" or "that"
  CH_: "viseme_CH_", // for "ch" in "church" or "change"
  A_CAT: "viseme_A_CAT", // for "a" in "cat"
  A_FACE: "viseme_A_FACE", // for "a" in "face"
};

export function Avatar(props) {
  const {
    responseData,
    setIsSpeaking,
    setIsListening,
    isSpeaking,
    startListening,
    setResponseData,
  } = useSpeechRecognitionContext();
  const [cues, setCues] = useState([]);
  const startTimeRef = useRef(0);
  const [audioUrl, setAudioUrl] = useState("");
  const audioRef = useRef(null);

  const smoothMorphTarget = true;
  const morphTargetSmoothing = 0.5;

  useEffect(() => {
    // const params = {
    //   OutputFormat: "mp3",
    //   Text: responseData,
    //   VoiceId: "Brian",
    // };

    // if (!responseData) return;

    const ssmlText = `<speak>${responseData}</speak>`;

    const params = {
      TextType: "ssml",
      OutputFormat: "mp3",
      Text: ssmlText,
      VoiceId: "Brian",
    };

    polly.synthesizeSpeech(params, (err, data) => {
      if (err) {
        console.log("Error synthesizing speech:", err);
      } else {
        const audioContent = Buffer.from(data.AudioStream).toString("base64");
        const audioUrl = `data:audio/mp3;base64,${audioContent}`;
        setAudioUrl(audioUrl);
        setResponseData("");
      }
    });
  }, [responseData]);

  useEffect(() => {
    if (audioUrl) {
      setIsSpeaking(true);
      audioRef.current = new Audio(audioUrl);
      audioRef.current.play();
    }
  }, [audioUrl, isSpeaking, startListening]);

  useEffect(() => {
    if (responseData) {
      const ssml = `
        <speak>
          <p>${responseData.replace(
            /"/g,
            (match) => `<say-as interpret-as="characters">${match}</say-as>`
          )}</p>
        </speak>
      `;

      const visemeParams = {
        OutputFormat: "json",
        SampleRate: "22050",
        Text: ssml,
        TextType: "ssml",
        VoiceId: "Brian",
        SpeechMarkTypes: ["viseme"],
      };

      polly.synthesizeSpeech(visemeParams, (err, data) => {
        if (err) {
          console.error("Error fetching viseme data:", err);
        } else {
          const jsonStr = Buffer.from(data.AudioStream).toString("utf8");
          const parsedJson = jsonStr
            .split("\n")
            .map((line) => {
              try {
                return JSON.parse(line);
              } catch (e) {
                return null;
              }
            })
            .filter((item) => item !== null);
          setCues(parsedJson);
          startTimeRef.current = performance.now() / 1000;
        }
      });
    }
  }, [responseData]);

  const { nodes, materials } = useGLTF("/models/667d2dc7ab338d43c837c83c.glb");

  useFrame(() => {
    const currentTime = performance.now() / 1000 - startTimeRef.current;

    for (let i = 0; i < cues.length; i++) {
      const mouthCue = cues[i];
      const startTime = mouthCue.time / 1000;
      const endTime = startTime + 0.3;

      if (currentTime >= startTime && currentTime <= endTime) {
        const viseme = corresponding[mouthCue.value.toUpperCase()] || "X";

        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 1;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 1;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[viseme]
            ],
            1,
            morphTargetSmoothing
          );

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
            ],
            1,
            morphTargetSmoothing
          );
        }

        break;
      } else {
        const viseme = corresponding[mouthCue.value.toUpperCase()] || "X";

        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = 0;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = 0;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[viseme]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[viseme]
            ],
            0,
            morphTargetSmoothing
          );

          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
            ],
            0,
            morphTargetSmoothing
          );
        }
      }
    }
  });

  return (
    <group {...props} dispose={null}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Glasses.geometry}
        material={materials.Wolf3D_Glasses}
        skeleton={nodes.Wolf3D_Glasses.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Headwear.geometry}
        material={materials.Wolf3D_Headwear}
        skeleton={nodes.Wolf3D_Headwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
}

useGLTF.preload("/models/667d2dc7ab338d43c837c83c.glb");
